/// Problem #2: Even Fibonacci numbers
///
/// Each new term in the Fibonacci sequence is generated by adding
/// the previous two terms. By starting with 1 and 2, the first 10
/// terms will be:
///
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
///
/// By considering the terms in the Fibonacci sequence whose values
/// do not exceed four million, find the sum of the even-valued
/// terms.

use std::iter::AdditiveIterator;
use std::mem;


struct Fibonacci {
    current: uint,
    next: uint,
}

// Implement 'Iterator' for 'Fibonacci'
impl Iterator<uint> for Fibonacci {
    // The 'Iterator' trait only requires the 'next' method to be defined. The
    // return type is 'Option<T>', 'None' is returned when the 'Iterator' is
    // over, otherwise the next value is returned wrapped in 'Some'
    fn next(&mut self) -> Option<uint> {
        let new_next = self.current + self.next;
        let new_current = mem::replace(&mut self.next, new_next);

        // 'Some' is always returned, this is an infinite value generator
        Some(mem::replace(&mut self.current, new_current))
    }
}

// Returns a fibonacci sequence generator
fn fibonacci() -> Fibonacci {
    Fibonacci { current: 1, next: 2 }
}

fn solve(exclusive_limit: uint) -> uint {
    fibonacci()
        .take_while(|&x| x < exclusive_limit)
        .filter(|&x| is_even(x))
        .sum()
}

fn is_even(x: uint) -> bool {
    x % 2 == 0
}

fn main() {
    println!("{}", fibonacci().take(10).collect::<~[uint]>());
    println!("{}", solve(4000000));
}

#[test]
fn test_fibonacci() {
    let expected = ~[1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
    let actual = fibonacci().take(10).collect::<~[uint]>();
    assert!(actual == expected);
}

#[test]
fn test_solution() {
    assert!(solve(4000000) == 4613732);
}
